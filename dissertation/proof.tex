\chapter{Proof}

% TODO
% make overline show up in mechanized proof and definitions, where necessary
% label mechanized proof better
% justify each semantic rule with a lemma
% label transition steps
% make beta appear in Redex stuff
% make sure the paper with Jay's suggestions is satisfied

The evaluation of a \cm\ program proceeds with the evolution of an evaluation context and reducible expression. When evaluation begins, the evaluation context is merely \scheme'hole', a placeholder for the eventual result. The evaluation of arguments--both in application and continuation mark forms--increases the size of the evaluation context. As these results are applied and evaluation continues, the size of the context fluctuates until finally, if the program terminates, we are left with a single value to plug in \scheme'hole'. This value is the value of the program.

The state of evalutation at any given point can be encapsulated by a pair of an evaluation context $E$ and an expression $e$ which we write in unorthodox style as $E[e]$. In order to prove that evaluation in the transformation corresponds to native evaluation, we must formally relate this state with its corresponding transformation.

The first step on this path is to define the transformation of a context. That is, for each context $E\in\lambda_{cm}$, we define $\C{E}$.

\begin{schemedefinition}{\scheme|Ccps[hole]|}
\begin{schemedisplay}
(lambda (value)
  value)
\end{schemedisplay}
\end{schemedefinition}

\begin{schemedefinition}{\scheme|Ccps[E[(hole rand-value)]]|}
\begin{schemedisplay}
(lambda (rator-value)
  (((Ccps[rand-expr]
     (lambda (rand-value)
       ((((rator-value rand-value) Ccps[E]) xiE) Cpcps[chiE])))
    FALSE)
  Cpcps[chiE]))
\end{schemedisplay}
\end{schemedefinition}

\begin{schemedefinition}{\scheme|Ccps[E[(v_0 hole)]]|}
\begin{schemedisplay}
(lambda (rand-value)
  ((((v_0 rand-value) Ccps[E]) xiE) Cpcps[chiE]))
\end{schemedisplay}
\end{schemedefinition}

\begin{schemedefinition}{\scheme|Ccps[E[(wcm hole body-expr)]]|}
\begin{schemedisplay}
(lambda (mark-value) 
  ((lambda (rest-marks) 
      (((Ccps[body-expr] Ccps[E]) TRUE) Cpcps[((CONS mark-value) rest-marks)]))
    ((xiE Chcps[(SND chiE)]) Cpcps[chiE])))
\end{schemedisplay}
\end{schemedefinition}

\begin{schemedefinition}{\scheme|Ccps[E[(wcm v_0 hole)]]|}
\begin{schemedisplay}
Ccps[E]
\end{schemedisplay}
\end{schemedefinition}

Next, we define a function $\xi$ over contexts $E$ which captures the state of \scheme'flag' as it is used in the transformation.

\begin{definition}
\[
\xi(E)=\begin{cases}
\mathbf{true} &\text{if $E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}\\
\mathbf{false} &\text{otherwise}
\end{cases}
\]
\end{definition}

We then recognize that \scheme'marks' as used in the transformation is \scheme|Cpcps[chiE]|. This allows us to relate $E[e]$ with $\C{E[e]}$ with the following definition.
\begin{schemedefinition}{\scheme|Ccps[E[e]]|}
\begin{schemedisplay}
(((Ccps[e] Ccps[E]) xiE) Cpcps[chiE])
\end{schemedisplay}
\end{schemedefinition}

From this definition, it is apparent that \scheme|Chcps[p]|=\scheme|(((Ccps[p] Ccps[hole]) XI(hole)) Cpcps[hole])|.

Finally, we define ``filling the hole'', the insertion of a value in the context from which it came.

\begin{schemedefinition}{\scheme|Ccps[E[v]]|}
\begin{schemedisplay}
(Ccps[E] Cpcps[v])
\end{schemedisplay}
\end{schemedefinition}

-----------

Before setting out on a formal proof, it may be useful to discuss certain invariants that
suggest the transform is correct. In general, there is a direct correspondence between
evaluation states--a context coupled with a possible redex--in \cm\ programs and their
transformations under $\mathcal{C}$. There is also necessarily a correspondence between
the behavior of the original program and its transform. For instance, once an expression
has been decomposed from its context, it is only recomposed with a value or more context.
This is exhibited in the transformed program by the application of the value to the
context, an artifact of the CPS transform which is semantically equivalent to ``filling
the hole''.

We will now set out to demonstrate that $\mathcal{C}$ preserves program meaning.

First, we define some useful shorthand.

We use Church encodings \cite{barendregt1984lambda} for booleans, lists, etc.

\begin{definition}
$\true=\abs{x}{\abs{y}{x}}$
\end{definition}

\begin{definition}
$\false=\abs{x}{\abs{y}{y}}$
\end{definition}

\begin{definition}
$\mathbf{pair}=\abs{a}{\abs{b}{\abs{z}{\app{\app{z}{a}}{b}}}}$
\end{definition}

\begin{definition}
$\mathbf{fst}=\abs{p}{\app{p}{\true}}$
\end{definition}

\begin{definition}
$\mathbf{snd}=\abs{p}{\app{p}{\false}}$
\end{definition}

\begin{definition}
$\nil=\false$
\end{definition}

\begin{definition}
If $e\lvrrs v$, $\eval{e}=v$.

The intent of this definition is to preserve visual indicators of the meaning of an
expression. For instance, it is used primarily to allow us to express the pair of $a$ and
$b$ as $\eval{\pair{a}{b}}$ instead of the less recognizable
$\abs{z}{\app{\app{z}{a}}{b}}$. However, it is dangerous since, in the case that $e$
diverges, we refer to a value that doesn't exist. We employ this definition only if it is
obvious that $e$ converges.
\end{definition}

\begin{definition}
$\C{E[e]}=\app{\app{\app{\C{e}}{\C{E}}}{\xi(E)}}{\C{\chi(E)}}$

When applied to both a context and term, $\mathcal{C}$ is treated as a two argument
function. While this in conventionally denoted $\Ct{E}{e}$ or similarly, we adopt the
unorthodox notation for consistency.
\end{definition}

\begin{definition}
$\C{E[v]}=\app{\C{E}}{\Cp{v}}$
\end{definition}





\begin{schemedefinition}{$\C{\hole}$}
\begin{schemeblock}
\begin{schemedisplay}
(lambda (v) C[v])
\end{schemedisplay}
\end{schemeblock}
\end{schemedefinition}

\begin{schemedefinition}{$\C{E[\app{\hole}{e_1}]}$}
\begin{schemeblock}
\begin{schemedisplay}
(lambda (a)
  (((Ce_1
     (lambda (b)
       ((((a b) CE) xiE) CchiE)))
    FALSE)
   CchiE))
\end{schemedisplay}
\end{schemeblock}
\end{schemedefinition}

\begin{schemedefinition}{$\C{E[\app{v_0}{\hole}]}$}
\begin{schemeblock}
\begin{schemedisplay}
(lambda (b) ((((Cpv_0 b) CE) xiE) CchiE))
\end{schemedisplay}
\end{schemeblock}
\end{schemedefinition}

\begin{schemedefinition}{$\C{E[\wcm{\hole}{e_1}]}$}
\begin{schemeblock}
\begin{schemedisplay}
(lambda (n) ((lambda (k) 
               (k (((CchiE (lambda (x) x)) (lambda (z) z)) (lambda (z) z))))
             (lambda (t) 
               ((lambda (k) (k ((f C[(SND t)]) t)))
                  (lambda (r) 
                    (((Ce_1 CE) TRUE) C[(PAIR v r)]))))))
\end{schemedisplay}
\end{schemeblock}
\end{schemedefinition}

\begin{namedschemedefinition}{c-wcm-v-hole}{$\C{E[\wcm{v_0}{\hole}]}$}
\begin{schemeblock}
\begin{schemedisplay}
CE
\end{schemedisplay}
\end{schemeblock}
\end{namedschemedefinition}

This definition is used solely as an abbreviation within the definition of
$\C{\wcm{e_0}{e_1}}$. Note that it is identical to $\C{\app{e_1}{e_1}}$ except that
$\mathcal{C}$ does not recur in the body of $\mathcal{A}$. Because of this, $\mathcal{A}$
has the property that $\mathcal{A}[\app{\C{e_0}}{\C{e_1}}]=\C{\app{e_0}{e_1}}$. This fact
is used to reinterpret particular terms at certain places in the reduction of
$\C{\wcm{e_0}{e_1}}$. In particular, it is necessary to create pairs in $\mathcal{C}$ ``by
hand'' when manipulating $\C{\chi(E)}$, which is defined in terms of applications in
$\mathcal{C}$.

\begin{definition}
$\Cp{v_0}=\Cp{\abs{x}{e_0}}=\abs{x}{\C{e_0}}$
\end{definition}

\begin{definition}
\[
\xi(E)=\begin{cases}
\mathbf{true} &\text{if $E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}\\
\mathbf{false} &\text{otherwise}
\end{cases}
\]
\end{definition}

\begin{definition}
\begin{align*}
\chi(\hole)               &= \nil\\
\chi(E[\app{\hole}{e_1}]) &= \chi(E)\\
\chi(E[\app{v_0}{\hole}]) &= \chi(E)\\
\chi(E[\wcm{\hole}{e_1}]) &= \chi(E)\\
\chi(E[\wcm{v_0}{\hole}]) &= \eval{\pair{v_0}{\chi(E)}}\\
\end{align*}
\end{definition}

\begin{definition}
\[
\mathrm{eval}_{cm}(p)=\begin{cases}
v     &\text{if $p\cmrrs v$}\\
\perp &\text{if $p\cmrrs\cdots$}
\end{cases}
\]
\end{definition}

\begin{definition}
\[
\mathrm{eval}_{v}(p)=\begin{cases}
v     &\text{if $p\lvrrs v$}\\
\perp &\text{if $p\lvrrs\cdots$}
\end{cases}
\]
\end{definition}

\begin{lemma}
\label{cm-app}
For all values $\abs{x}{e_0}$ and $\abs{y}{e_1}$, $\app{\Cp{\abs{x}{e_0}}}{\Cp{\abs{y}{e_1}}}\lvrr\C{e_0[x\leftarrow \abs{y}{e_1}]}$.
\end{lemma}

\begin{proof}
\begin{align*}
\app{\Cp{\abs{x}{e_0}}}{\Cp{\abs{y}{e_1}}} = &\app{\abs{x}{\C{e_0}}}{\abs{y}{\C{e_1}}}&\text{by definition of $\mathcal{C}'$}\\
                                       \lvrr &\C{e_0}[x\leftarrow \abs{y}{\C{e_1}}]&\text{by semantics of \lv}\\
                                           = &\C{e_0[x\leftarrow \abs{y}{e_1}}]&\text{Think about it.}
\end{align*}
(It's obvious.)
\end{proof}

\begin{lemma}
\label{hole-context-to-value}
For all values $\abs{x}{e}$, $\app{\C{\hole}}{\Cp{\abs{x}{e}}}=\C{\abs{x}{e}}$.
\end{lemma}

\begin{proof}
\begin{align*}
\app{\C{\hole}}{\Cp{\abs{x}{e}}} = &\app{\abs{v}{\C{v}}}{\Cp{\abs{x}{e}}}\\
                                 = &\app{\abs{v}{\C{v}}}{\abs{x}{\C{e}}}\\
                             \lvrr &\C{v}[v\leftarrow \abs{x}{\C{e}}]\\
                                 = &\C{v[v\leftarrow \abs{x}{e}]}\\
                                 = &\C{\abs{x}{e}}
\end{align*}
\end{proof}

\begin{lemma}
\label{wcm-collapse}
If $E=E'[\wcm{v'}{\hole}]$, then $\chi(E'[\wcm{v_0}{\hole}])=\eval{\pair{v_0}{\app{\mathbf{snd}}{\chi(E)}}}$.
\end{lemma}

\begin{proof}
\begin{align*}
\chi(E'[\wcm{v_0}{\hole}]) &= \eval{\pair{v_0}{\chi(E')}}\\
                           &= \eval{\pair{v_0}{\app{\mathbf{snd}}{\chi(E'[\wcm{v'}{\hole}])}}}\\
                           &= \eval{\pair{v_0}{\app{\mathbf{snd}}{\chi(E)}}}\\
\end{align*}
\end{proof}

\newtheorem*{eqtheorem}{Equivalence Theorem}
\begin{eqtheorem}
For all contexts $E\in\lambda_{cm}$ and expressions $e\in\lambda_{cm}$, $E[e]\cmrrs\cdots\implies\C{E[e]}\lvrrs\cdots$ and $E[e]\cmrrs v\implies\C{E[e]}\lvrrs \C{v}$.
\end{eqtheorem}

We will reason by structural induction on both contexts $E$ and terms $e$. Instead of
nesting the induction, which requires the consideration of $|E|\cdot|e|$ cases, we will
take first $E$ and then $e$ in isolation, in each assuming the correctness of the other,
which requires the consideration of only $|E|+|e|$ cases.

First, we will prove the correctness for terms $e$. Assume that for all contexts $E$,
$E[v']\cmrrs v\implies\C{E[v']}\lvrrs v$.

In each case, let $E$ be an arbitrary context.

\begin{proof}[Case $e=\app{e_0}{e_1}$]
By structural induction, assume that 
\[
E[\app{\hole}{e_1}][e_0]\cmrrs\cdots\implies\C{E[\app{\hole}{e_1}][e_0]}\lvrrs\cdots
\]
and
\[
E[\app{\hole}{e_1}][e_0]\cmrrs E[\app{\hole}{e_1}][v_0]\implies\C{E[\app{\hole}{e_1}][e_0]}\lvrrs\C{E[\app{\hole}{e_1}][v_0]}
\]
and similarly
\[
E[\app{v_0}{\hole}][e_1]\cmrrs\cdots\implies\C{E[\app{v_0}{\hole}][e_1]}\lvrrs\cdots
\]
and
\[
E[\app{v_0}{\hole}][e_1]\cmrrs E[\app{v_0}{\hole}][v_1]\implies\C{E[\app{v_0}{\hole}][e_1]}\lvrrs\C{E[\app{v_0}{\hole}][v_1]}
\]
In each case, divergence is lifted to the entire program. Consider the case where $E[\app{\hole}{e_1}][e_0]\cmrrs E[\app{\hole}{e_1}][v_0]$ and $E[\app{v_0}{\hole}][e_1]\cmrrs E[\app{v_0}{\hole}][v_1]$.

$\C{E[\app{e_0}{e_1}]}\lvrrs\C{E[\app{\hole}{e_1}][e_0]}$, by app1-app7.

$\C{E[\app{\hole}{e_1}][e_0]}\lvrrs\C{E[\app{\hole}{e_1}][v_0]}$, by the induction hypothesis.

$\C{E[\app{\hole}{e_1}][v_0]}\lvrrs\C{E[\app{v_0}{\hole}][e_1]}$, by app8-app9.

$\C{E[\app{v_0}{\hole}][e_1]}\lvrrs\C{E[\app{v_0}{\hole}][v_1]}$, by the induction hypothesis.

$\C{E[\app{v_0}{\hole}][v_1]}\lvrr\C{E[\app{v_0}{v_1}]}$, by app11.

By Lemma \ref{cm-app},
\[
E[\app{v_0}{v_1}]\cmrr E[e']\implies\C{E[\app{v_0}{v_1}]}\lvrrs\C{E[e']}
\]
and $\C{E[e']}\lvrrs\C{E[v']}$ follows by induction.
\end{proof}

\begin{proof}[Case $e=\wcm{e_0}{e_1}$]
By structural induction, assume that 
\[
E[\wcm{\hole}{e_1}][e_0]\cmrrs\cdots\implies\C{E[\wcm{\hole}{e_1}][e_0]}\lvrrs\cdots
\]
and
\[
E[\wcm{\hole}{e_1}][e_0]\cmrrs E[\wcm{\hole}{e_1}][v_0]\implies\C{E[\wcm{\hole}{e_1}][e_0]}\lvrrs\C{E[\wcm{\hole}{e_1}][v_0]}
\]
and similarly
\[
E[\wcm{v_0}{\hole}][e_1]\cmrrs\cdots\implies\C{E[\wcm{v_0}{\hole}][e_1]}\lvrrs\cdots
\]
and
\[
E[\wcm{v_0}{\hole}][e_1]\cmrrs E[\wcm{v_0}{\hole}][v_1]\implies\C{E[\wcm{v_0}{\hole}][e_1]}\lvrrs\C{E[\wcm{v_0}{\hole}][v_1]}
\]
Similar to the case of application, divergence is lifted to the entire program. Consider the case where $E[\wcm{\hole}{e_1}][e_0]\cmrrs E[\wcm{\hole}{e_1}][v_0]$ and $E[\wcm{v_0}{\hole}][e_1]\cmrrs E[\wcm{v_0}{\hole}][v_1]$.


$\C{E[\wcm{e_0}{e_1}]}\lvrrs\C{E[\wcm{\hole}{e_1}][e_0]}$, by wcm1-wcm7.

$\C{E[\wcm{\hole}{e_1}][e_0]}\lvrrs\C{E[\wcm{\hole}{e_1}][v_0]}$, by the induction hypothesis.

\begin{case}{$E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}

$\C{E'[\wcm{v'}{\wcm{\hole}{e_1}}][v_0]}\lvrrs\C{E'[\wcm{v_0}{\hole}][e_1]}$, by wcm9-wcm18-tail.
\end{case}

\begin{case}{$E\ne E'[\wcm{v'}{\hole}]$ for any $E'$ and $v'$}

$\C{E[\wcm{v_0}{e_1}]}\lvrrs\C{E[\wcm{v_0}{\hole}][e_1]}$, by wcm9-wcm18-no-tail.
\end{case}

Now let 
\[
E''=\begin{cases}
E' &\text{if $E=E'[\wcm{v'}{\hole}]$ for some $E'$ and $v'$}\\
E  &\text{otherwise}
\end{cases}
\]

$\C{E''[\wcm{v_0}{\hole}][e_1]}\lvrrs\C{E''[\wcm{v_0}{\hole}][v_1]}$, by the inductive hypothesis.

$\C{E''[\wcm{v_0}{\hole}][v_1]}=\C{E''[v_1]}$, by wcm19.

\end{proof}

\begin{proof}[Case $e=\ccm$]
$\C{E[\ccm]}\lvrrs\C{E[\chi(E)]}$, by ccm1-ccm3.
\end{proof}

\begin{proof}[Case $e=v$]
$\C{E[v]}\lvrrs\C{E[v]}$, by v1-v2.
\end{proof}

\begin{proof}[Case $e=x$]
$\C{E[x]}\lvrrs$\scheme'C[error]', by x1-x4.
\end{proof}

\begin{proof}[Case $e=$\scheme'error']
% prove E[error] -> error => ((C[error] C[E]) ((pair xi(E)) C[chi(E)])) -> C[error]
\end{proof}

Now, we will prove the correctness for contexts $E$. Assume that for all terms $e$,
$E[e]\cmrrs E[v]\implies\C{E[e]}\lvrrs \C{E[v]}$.

In each case, let $e$ be an arbitrary term which evaluates to $v$.

\begin{proof}{Case $E=\hole$}

$\C{\hole[e]}\lvrrs\C{\hole[v]}$, by assumption.

$\C{\hole[v]}\lvrr\C{v}$, by [a lemma].
\end{proof}

\begin{proof}{Case $E=E'[\app{\hole}{e_1}]$}

$\C{E'[\app{\hole}{e_1}][e_0]}\lvrrs\C{E'[\app{\hole}{e_1}][v_0]}$, by assumption.

$\C{E'[\app{\hole}{e_1}][v_0]}\lvrr\C{E'[\app{v_0}{\hole}][e_1]}$, by app8.

We defer to the inductive hypothesis.
\end{proof}

\begin{proof}{Case $E=E'[\app{v_0}{\hole}]$}

$\C{E'[\app{v_0}{\hole}][e_1]}\lvrrs\C{E'[\app{v_0}{\hole}][v_1]}$, by assumption.

$\C{E'[\app{v_0}{\hole}][v_1]}\lvrr\C{E'[\app{v_0}{v_1}]}$, by app9.

$\C{E'[\app{v_0}{v_1}]}\lvrr\C{E'[e]}$ for some $e$, by assumption.

We defer to the inductive hypothesis.
\end{proof}

\begin{proof}{Case $E=E'[\wcm{\hole}{e_1}]$}

$\C{E'[\wcm{\hole}{e_1}][e_0]}\lvrrs\C{E'[\wcm{\hole}{e_1}][v_0]}$, by assumption.

\begin{case}{$E'=E''[\wcm{v'}{\hole}]$ for some $E''$ and $v'$}

$\C{E'[\wcm{\hole}{e_1}][v_0]}\lvrrs\C{E''[\wcm{v_0}{\hole}][e_1]}$, by wcm9-wcm18-tail.
\end{case}

\begin{case}{$E'\ne E''[\wcm{v'}{\hole}]$ for any $E''$ and $v'$}

$\C{E'[\wcm{\hole}{e_1}][v_0]}\lvrrs\C{E'[\wcm{v_0}{\hole}][e_1]}$, by wcm9-wcm18-not-tail.
\end{case}

We defer to the inductive hypothesis.
\end{proof}

\begin{proof}{Case $E=E'[\wcm{v'}{\hole}]$}

$\C{E'[\wcm{v'}{\hole}][e]}\lvrrs\C{E'[\wcm{v'}{\hole}][v]}$, by assumption.

$\C{E'[\wcm{v'}{\hole}][v]}\lvrr \C{E'[v]}$, by wcm19. 
\end{proof}

\newtheorem*{maintheorem}{Correctness of $\mathcal{C}$}
\begin{maintheorem}
For all programs $p\in\lambda_{cm}$, $\C{\mathrm{eval}_{cm}(p)}=\mathrm{eval}_{v}(\C{p})$.
\end{maintheorem}

\begin{proof}

\begin{align*}
p\cmrrs v &\implies\mathrm{eval}_{cm}(p)=v &\text{(by definition of $\mathrm{eval}_{cm}$)}\\
          &\implies\C{\mathrm{eval}_{cm}(p)}=\C{v} &\text{(by well-definedness of $\mathcal{C}$)}
\end{align*}

% define C[E[e]]
% define C[E]
% define C[e]

% E[(e0 e1)] *
% E[(* e1)][e0] *
% E[(* e1)][v0] *
% E[(v0 e1)] ~
% E[(v0 *)][e1] *
% E[(v0 *)][v1] *
% E[(v0 v1)] ~*
% E[e2] * by induction

% E[(wcm e0 e1)] *
% E[(wcm * e1)][e0] *
% E[(wcm * e1)][v0] *
% E[(wcm v0 e1)] ~
% E[(wcm v0 *)][e1] ~?
% E[(wcm v0 *)][v1] ~?
% E[(wcm v0 v1)] ~
% E[v1] *

% E'[(wcm v' *][(wcm e0 e1)] *
% E'[(wcm v' (wcm * e1))][e0] *
% E'[(wcm v' (wcm * e1))][v0] ~
% E'[(wcm v' (wcm v0 e1))] ~
% E'[(wcm v0 e1)] ~
% E'[(wcm v0 *)][e1] ~?
% E'[(wcm v0 *)][v1] ~
% E'[(wcm v0 v1)] ~
% E'[v1] *

% E[(ccm)] *
% E[chi(E)] *

% define C[E[v]] (C[E] C'[v])

\begin{align*}
p\cmrrs v &\implies\hole[p]\cmrrs v &\text{(since $p\cmrr\hole[p]$)}\\
          &\implies\C{\hole[p]}\lvrrs\C{v} &\text{(by the Great Lemma)}\\
          &\implies\app{\app{\C{p}}{\C{\hole}}}{\eval{\pair{\xi(\hole)}{\C{\chi(\hole)}}}}\lvrrs\C{v}&\text{(by definition of $\mathcal{C}$)}\\
          &\implies\mathrm{eval}_{v}(\C{p})=\C{v} &\text{(by definition of $\mathrm{eval}_v$)}
\end{align*}

Therefore, $\C{\mathrm{eval}_{cm}(p)}=\mathrm{eval}_{v}(\C{p})$.
\end{proof}

