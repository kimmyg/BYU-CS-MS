monads
- category theoretic roots
- modularity

continuation marks
- examples

a monad for continuation marks

change joke definition of monad, add citation to "category theory for the working mathematician", pg. 138

document:

24 April 2012
do presentation with HTML/CSS? I could do it with Racket slideshow, but I don't know if I need that...

papers (for today):
featherweight java
category theory for the working mathematician
slideshow: functional presentations
functional pearls: probabilistic functional programming in haskell
monads need not be endofunctors
monadic framework for delimited continuations
abstracting abstract machines
termination in language-based systems
a tail-recursive machine with stack inspection
little languages and their programming environments
control operators, the secd-machine, and the lambda calculus
a correspondence between algol 60 and church's lambda-notation
language-based information-flow security

Lack of Modularity in Denotational Semantics*

E : Term -> Value
E[[n]] = n
E[[e_{1}+e_{2}]] = E[[e_{1}]]+E[[e_{2}]]

* Modular Monadic Semantics

Introduce an environment to allow the use of variables and functions

E : Term -> Env -> Value
E[[n]] = \p.n
E[[e_{1}+e_{2}]] = \p.E[[e_{1}]]p+E[[e_{2}]]p
E[[v]] = \p p[[v]]

Introduce continuations to allow sequencing

E : Term -> Env -> (Value -> Ans) -> Ans
E[[n]] = \p.\k. k n
E[[e_{1}+e_{2}]]=\p.\k.(E[[e_{1}]]p(\i.E[[e_{2}]]p(\j.k(i+j)))
E[[v]] = \p.\k. k p[[v]] or p[[v]](\x.k x)
E[[e_{1};e_{2}]]=\p.\k.E[[e_{1}]]p(\x.E[[e_{2}]]p k)

This is not a modular approach

The addition of a construct (wc) requires global changes to the definition.
"regarded by many as the most significant obstacle in applying denotational semantics to realistic programming languages"

(still can't say exactly why behavioral are not sufficient. if the reason is of the same nature as above, we can dismiss them similarly. if the reason is different, we must expose it.)

Monadic semantics solve these problems. I'm not introducing them here; they've been applied copiously/comprehensively/generously/something along these lines. (Cite papers on monadic semantics.)

Monadic semantics are a way of formalizing a language feature (?)

Introduce continuation marks

The continuation refers to the "rest of the computation".
A continuation mark is an annotation on the "rest of the computation".
A typical/standard representation of the continuation is the call stack. In this case, continuation marks amount to stack annotations. (oversimplification?)

Example

(w-c-m key-expr value-expr body-expr)
(w-c-m 'key 'outer (if x (wcm 'key 'inner (c-c-m 'key))))

Useful for fluid let values, debuggers, profilers, steppers.

Explain use in fluid lets and steppers.

I propose that continuation marks have a monadic semantics.

Behavioral semantics given for continuation marks. Will prove equivalence.
Monads have specific laws that must be satisfied. Will prove they hold.

(return x) >>= f = f x (left identity)
m >>= return = m (right identity)
(m >>= f) >>= g = m >>= (\x -> f x >>= g) (associativity)

(return x) >>= f
= CM1 (\_ -> x) >>= f
= CM1 (\vs -> let (CM1 m') = f ((\_ -> x) (Nothing:vs)) in m' vs)
= CM1 (\vs -> let (CM1 m') = f x in m' vs)
= CM1 (\vs -> [unwrap](f x) vs)
= wrapped f x

(CM1 m) >>= return
= CM1 (\vs -> let (CM1 m') = return (m (Nothing:vs)) in m' vs)
= CM1 (\vs -> let (CM1 m') = CM1 (\_ -> m (Nothing:vs)) in m' vs)
= CM1 (\vs -> (\_ -> m (Nothing:vs)) vs)
= CM1 (\vs -> m (Nothing:vs))
= (CM1 m) with another continuation mark (can we argue that these are "transparent"?)

((CM1 m) >>= f) >>= g
= (CM1 (\vs -> let (CM1 m') = f (m (Nothing:vs)) in m' vs)) >>= g
= (CM1 (\vs -> let (CM1 m') = g ((\vs -> let (CM1 m') = f (m (Nothing:vs)) in m' vs) (Nothing:vs)) in m' vs))
= (CM1 (\
= (CM1 m) >>= (\x -> f x >>= g)

suppose the monad was in fact just the computations (no wrapping CM1)

return x = (\_ -> x)
m >>= f = (\vs -> f (m (Nothing:vs)) vs)

(return x) >>= f
= (\_ -> x) >>= f [definition of return]
= (\vs -> f ((\_ -> x) (Nothing:vs)) vs) [definition of bind]
= (\vs -> f x vs) [application (reduction?)]
= f x [application]

m >>= return
= (\vs -> return (m (Nothing:vs)) vs) [definition of bind]
= (\vs -> (\_ -> m (Nothing:vs)) vs) [definition of return]
= (\vs -> m (Nothing:vs)) [application]

(m >>= f) >>= g
= (\vs -> f (m (Nothing:vs)) vs) >>= g [definition of bind]
= (\vs -> g ((\vs -> f (m (Nothing:vs)) vs) (Nothing:vs)) vs) [definition of bind]
= (\vs -> g ((f (m (Nothing:vs))) (Nothing:vs)) vs) [application]
= (\vs -> (\x -> g ((f x) (Nothing:vs))) (m (Nothing:vs)) vs) [abstraction]
= (\vs -> (\x -> f x >>= g) (m (Nothing:vs)) vs) [definition of bind]
= m >>= (\x -> f x >>= g) [definition of bind]


