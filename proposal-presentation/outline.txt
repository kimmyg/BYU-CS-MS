Thesis: Continuation marks are amenable to a monadic semantics.

Lack of Modularity in Denotational Semantics*

E : Term -> Value
E[[n]] = n
E[[e_{1}+e_{2}]] = E[[e_{1}]]+E[[e_{2}]]

* Modular Monadic Semantics

Introduce an environment to allow the use of variables and functions

E : Term -> Env -> Value
E[[n]] = \p.n
E[[e_{1}+e_{2}]] = \p.E[[e_{1}]]p+E[[e_{2}]]p
E[[v]] = \p p[[v]]

Introduce continuations to allow sequencing

E : Term -> Env -> (Value -> Ans) -> Ans
E[[n]] = \p.\k. k n
E[[e_{1}+e_{2}]]=\p.\k.(E[[e_{1}]]p(\i.E[[e_{2}]]p(\j.k(i+j)))
E[[v]] = \p.\k. k p[[v]] or p[[v]](\x.k x)
E[[e_{1};e_{2}]]=\p.\k.E[[e_{1}]]p(\x.E[[e_{2}]]p k)

This is not a modular approach

The addition of a construct (wc) requires global changes to the definition.
"regarded by many as the most significant obstacle in applying denotational semantics to realistic programming languages"

(still can't say exactly why behavioral are not sufficient. if the reason is of the same nature as above, we can dismiss them similarly. if the reason is different, we must expose it.)

Monadic semantics solve these problems. I'm not introducing them here; they've been applied copiously/comprehensively/generously/something along these lines. (Cite papers on monadic semantics.)

Monadic semantics are a way of formalizing a language feature (?)

Introduce continuation marks

The continuation refers to the "rest of the computation".
A continuation mark is an annotation on the "rest of the computation".
A typical/standard representation of the continuation is the call stack. In this case, continuation marks amount to stack annotations. (oversimplification?)

Example

(w-c-m key-expr value-expr body-expr)
(w-c-m 'key 'outer (if x (wcm 'key 'inner (c-c-m '(key)))))

Useful for fluid let values, debuggers, profilers, steppers.

Explain use in fluid lets and steppers.

I propose that continuation marks have a monadic semantics.

Behavioral semantics given for continuation marks. Will prove equivalence.
Monads have specific laws that must be satisfied. Will prove they hold.

(return x) >>= f = f x (left identity)
m >>= return = m (right identity)
(m >>= f) >>= g = m >>= (\x -> f x >>= g) (associativity)
